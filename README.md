# React Handler Function Stability Demo

这个项目演示了 React 中的两个重要问题：
1. 事件处理函数的稳定性问题
2. 动态列表渲染时的性能优化问题

## 问题描述

这个示例展示了两个常见的 React 性能问题：

1. **事件处理函数稳定性**：
   - 即使使用了 `React.memo`，不稳定的事件处理函数仍会导致不必要的重渲染
   - 每次父组件渲染时，内联的事件处理函数都会创建新的实例

2. **动态列表渲染**：
   - 列表长度随时间变化（0-3个元素）
   - 即使未改变的元素也会因为事件处理函数的重新创建而重新渲染

## 关键观察点

1. **动态列表**：
   - "Update" 按钮显示当前列表长度
   - 每次点击会随机显示0-3个按钮
   - 观察按钮的出现和消失

2. **渲染行为**：
   - 即使按钮数量没变，现有按钮也会重新渲染
   - 每个按钮都维护着自己的渲染计数
   - 通过渲染计数可以清楚地看到不必要的重渲染

3. **性能问题**：
   - 每次父组件更新时创建新的事件处理函数：`onClick={() => onClick(user, Date.now())}`
   - `React.memo` 因为接收到新的函数引用而失效
   - 即使按钮内容和行为没有变化，也会重新渲染

## 实验步骤

1. 运行项目：
   ```bash
   npm install
   npm run dev
   ```

2. 观察实验：
   - 打开浏览器控制台
   - 反复点击 "Update" 按钮
   - 观察以下现象：
     * 按钮数量的变化
     * 每个按钮的渲染计数
     * 控制台中的函数引用日志

3. 注意事项：
   - 观察按钮数量保持不变时的重渲染情况
   - 注意新增按钮的初始渲染计数
   - 对比不同按钮的渲染计数差异

## 性能优化建议

3. **组件结构优化**：
   - 拆分动态和静态内容
   - 使用 `useMemo` 缓存列表计算结果
   - 考虑使用状态管理工具

## 启示

这个示例展示了 React 中的两个常见性能陷阱：
1. 内联函数导致的 `React.memo` 失效
2. 动态列表中的不必要重渲染

理解这些问题对于构建高性能的 React 应用至关重要，同时也说明了为什么一些新的框架（如 Solid.js）采用了不同的设计方案来避免这些问题。
